- 3.2 程序编码
    - 3.2.1 机器级表示
        - 抽象
            - 计算机系统使用了多种不同形式的抽象, 利用更简单的抽象模型来隐藏实现的细节
            - 最重要的两种抽象:
                1. 由指令集体系结构(Instruction Set Architecture, ISA)来定义机器级程序的格式和行为.
                2. 机器级程序使用的内存地址是虚拟地址, 提供的内存模型看上去是一个非常大的字节数组
        - 处理器状态
            - 程序计数器(通常被称为"PC", 在x86-64中用%rip表示): 给出将要执行的下一条指令在内存中的地址
    - 3.2.2 代码示例
        - 汇编与反汇编程序
            - 汇编: gcc
                - ```linux> gcc -Og -S mstore.c```
                    - 这会使GCC运行编辑器, 产生一个汇编文件mstore.s, 但是不做其他进一步的工作. (通常情况下, 它还会继续调用汇编器产生目标代码文件)
                - ```linux> gcc -Og -c mstore.c```
                    - 这会产生目标代码文件mstore.o, 它是二进制格式的, 所以无法直接查看
            - 反汇编: objdump
                - ```linux> objdump -d mstore.o```
                    - 这些反汇编程序(像objdump)会根据机器代码产生一种类似汇编代码的格式
        - 链接器
            - l链接器(Linker)是一个程序, 将一个或多个由编译器或汇编器生成的目标文件外加库链接为一个可执行文件
    - 3.2.3 关于格式的注释
        - 以"."开头的行
            - 都是指导汇编器和链接器工作的伪命令
        - 把C语言和汇编语言结合起来
            - 方法:
                1. 我们可以编写完整的函数, 放进一个独立的汇编文件中, 让汇编器和链接器把它和用C语言编写的代码合并起来
                2. 我们可以使用GCC的内联汇编(inline assembly)特性, 用asm伪指令可以在C程序中包含简短的汇编代码
                    - 好处: 减少代码量
                    - 坏处: 会使代码与某些特殊的机器有关,所以只应该在想要的特性只能以这种方式才能访问到时才使用它
- 3.3 数据格式
    - 由于是从16位体系结构扩展成32字, Intel用术语"字(word)"表示16位数据类型. 因此32位数为"双字(double words)", 称64位数为"四字(quad words)".
    - 数据格式的汇编后缀:
        - 后缀"l": 表示4字节整数和8字节双精度浮点数, 这样不会产生歧义, 因为浮点数使用的是一组完全不同的指令和寄存器